diff --git a/index1.html b/index1.html
index 9f0c9480216c22ba2cc708d55c04bf1937174c21..77640f094ec441f0690c76f293b68d3e0c75a83c 100644
--- a/index1.html
+++ b/index1.html
@@ -1014,254 +1014,274 @@ body {
       // very soft sounds
 
       const flipSound = new Audio(
         "https://actions.google.com/sounds/v1/impacts/metal_parts_cling.ogg",
       );
       const correctSound = new Audio(
         "https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg",
       );
 
       flipSound.volume = 0.2;
       correctSound.volume = 0.07;
 
       function toggleSound() {
         soundOn = !soundOn;
         localStorage.setItem("soundOn", JSON.stringify(soundOn));
         updateSoundIcon();
       }
 
       function updateSoundIcon() {
         const el = document.getElementById("soundIcon");
         if (el) el.textContent = soundOn ? "üîä" : "üîá";
       }
 
       /* ===== DATA ===== */
 
-let returnToTopicAfterSave = null;
-
-function createTopic(title, source = "local", hubMeta = null) {
-  return {
-    id: crypto.randomUUID(),
-    title,
-    source,
-    hubMeta,
-    words: []
-  };
-}
+let returnToTopicAfterSave = null;
+
+function uuid() {
+  // Use crypto.randomUUID when available, otherwise fallback.
+  if (typeof crypto !== "undefined" && crypto.randomUUID) {
+    return crypto.randomUUID();
+  }
+  return `id-${Date.now()}-${Math.random().toString(16).slice(2)}`;
+}
+
+function createTopic(title, source = "local", hubMeta = null) {
+  return {
+    id: uuid(),
+    title,
+    source,
+    hubMeta,
+    words: []
+  };
+}
 
 let data = JSON.parse(localStorage.getItem(FLASH_KEY)) || {
   topics: {} // topicId -> { id, title, source, hubMeta, words }
 };
 
       let stats = JSON.parse(localStorage.getItem(STATS_KEY)) || {
         sessions: 0,
         history: [],
         perTopic: {},
         hardWords: {},
       };
 
       const topicSelect = document.getElementById("topicSelect");
 
       topicSelect.onchange = function () {
         setCurrentTopic(this.value);
       };
 
       const bankTopicSelect = document.getElementById("bankTopicSelect");
       const bankListTopicSelect = document.getElementById(
         "bankListTopicSelect",
       );
       bankListTopicSelect.onchange = switchBankListTopic;
 
       const searchInput = document.getElementById("searchInput");
       const sortSelect = document.getElementById("sortSelect");
       const wordList = document.getElementById("wordList");
       const addTopicSelect = document.getElementById("addTopicSelect");
       const learnInput = document.getElementById("learnInput");
       const translationInput = document.getElementById("translationInput");
       const newTopicInput = document.getElementById("newTopicInput");
       const importFile = document.getElementById("importFile");
       const shuffleBtn = document.getElementById("shuffleBtn");
       const card = document.getElementById("card");
 
 let lastAddTopic = null;
 
 
       /* ===== HUB INDEX ===== */
 
-      // state (HUB is read-only)
-      let hubIndex = null;
-      let currentTopic = null;
+      // state (HUB is read-only)
+      let hubIndex = null;
+      let hubIndexLoaded = false;
+      let currentTopic = null;
 
       /*
 Expected structure:
 {
   version: number,
   languages: [{ id, title }],
   branches: [{ id, title }],
   entries: [
     {
       branch: string,
       group: string,
       files: { [lang]: string[] }
     }
   ]
 }
 */
 
-      function loadHubIndex() {
-        if (!window.HUB_INDEX) {
-          alert("Word Library is not available right now.");
-          return false;
-        }
+      function loadHubIndex() {
+        if (hubIndexLoaded) return true; // guard: avoid reloading
+        if (!window.HUB_INDEX) {
+          console.warn("HUB_INDEX is missing.");
+          alert("Word Library is not available right now.");
+          return false;
+        }
 
         const idx = window.HUB_INDEX;
 
         // basic shape validation
-        if (
-          typeof idx !== "object" ||
-          !Array.isArray(idx.languages) ||
-          !Array.isArray(idx.branches) ||
-          !Array.isArray(idx.entries)
-        ) {
-          alert("Word Library is corrupted.");
-          return false;
-        }
-
-        hubIndex = idx;
-        return true;
-      }
-
-      /* ===== UTIL ===== */
-
-      function save() {
-        localStorage.setItem(FLASH_KEY, JSON.stringify(data));
-        localStorage.setItem(STATS_KEY, JSON.stringify(stats));
-      }
+        if (
+          typeof idx !== "object" ||
+          !Array.isArray(idx.languages) ||
+          !Array.isArray(idx.branches) ||
+          !Array.isArray(idx.entries)
+        ) {
+          console.warn("HUB_INDEX has an invalid structure.");
+          alert("Word Library is corrupted.");
+          return false;
+        }
+
+        hubIndex = idx;
+        hubIndexLoaded = true;
+        return true;
+      }
+
+      /* ===== UTIL ===== */
+
+      function saveData() {
+        localStorage.setItem(FLASH_KEY, JSON.stringify(data));
+      }
+
+      function saveStats() {
+        localStorage.setItem(STATS_KEY, JSON.stringify(stats));
+      }
 
       function setCurrentTopic(topicId) {
   currentTopic = topicId || null;
 
   if (topicSelect) topicSelect.value = topicId || "";
   if (bankTopicSelect) bankTopicSelect.value = topicId || "";
   if (bankListTopicSelect) bankListTopicSelect.value = topicId || "";
 }
 
 
       /* ===== TOPIC NAME GATE ===== */
 
-      function normalizeTopicName(name) {
-        return name
-          .trim()
-          .replace(/\s+/g, " ") // ◊®◊ï◊ï◊ó◊ô◊ù ◊õ◊§◊ï◊ú◊ô◊ù ‚Üí ◊®◊ï◊ï◊ó ◊ê◊ó◊ì
-          .toLowerCase(); // ◊ë◊ú◊ô ◊î◊ë◊ì◊ú ◊ê◊ï◊™◊ô◊ï◊™
-      }
-
+      function normalizeTopicName(name) {
+        return name
+          .trim()
+          .replace(/\s+/g, " ") // ◊®◊ï◊ï◊ó◊ô◊ù ◊õ◊§◊ï◊ú◊ô◊ù ‚Üí ◊®◊ï◊ï◊ó ◊ê◊ó◊ì
+          .toLowerCase(); // ◊ë◊ú◊ô ◊î◊ë◊ì◊ú ◊ê◊ï◊™◊ô◊ï◊™
+      }
+
+      function isTopicTitleAvailable(title, excludeId = null) {
+        const norm = normalizeTopicName(title);
+
+        return !Object.values(data.topics).some((t) => {
+          if (excludeId && t.id === excludeId) return false;
+          return normalizeTopicName(t.title) === norm;
+        });
+      }
+
       /*
 mode:
 - "create"  ‚Üí ◊ô◊¶◊ô◊®◊™ ◊ò◊ï◊§◊ô◊ß ◊ó◊ì◊© (ADD / IMPORT / DOWNLOAD)
 - "rename"  ‚Üí ◊©◊ô◊†◊ï◊ô ◊©◊ù ◊ò◊ï◊§◊ô◊ß
 */
 
 
-function isTopicTitleTaken(title, excludeId = null) {
-  const norm = normalizeTopicName(title);
-
-  return Object.values(data.topics).some((t) => {
-    if (excludeId && t.id === excludeId) return false;
-    return normalizeTopicName(t.title) === norm;
-  });
-}
+function isTopicTitleTaken(title, excludeId = null) {
+  return !isTopicTitleAvailable(title, excludeId);
+}
 
       function validateTopicName(name, mode, currentName = null) {
         const n = normalizeTopicName(name);
 
         if (!n) {
           alert("Topic name is empty");
           return null;
         }
 
         // ◊ô◊¶◊ô◊®◊™ ◊ò◊ï◊§◊ô◊ß ◊ó◊ì◊©
         if (mode === "create") {
           if (data.topics[n]) {
             alert(`Topic "${n}" already exists`);
             return null;
           }
           return n;
         }
 
         // ◊©◊ô◊†◊ï◊ô ◊©◊ù
         if (mode === "rename") {
           if (n === currentName) return n; // ◊ê◊ï◊™◊ï ◊©◊ù ‚Äì ◊û◊ï◊™◊®
           if (data.topics[n]) {
             alert(`Topic "${n}" already exists`);
             return null;
           }
           return n;
         }
 
         console.error("Unknown topic name validation mode:", mode);
         return null;
       }
 
       function allWords() {
   let a = [];
   Object.values(data.topics).forEach((topic) => {
     a.push(...topic.words);
   });
   return a;
 }
 
 
       /* ===== LIBRARY ‚Üí FC TOPIC ===== */
-      function saveCSVAsTopic(csvText, topicTitle, source = "hub", hubMeta = null) {
-  // ◊ô◊¶◊ô◊®◊™ topic ◊ó◊ì◊©
-  const topic = createTopic(topicTitle, source, hubMeta);
+      function saveCSVAsTopic(csvText, topicTitle, source = "hub", hubMeta = null) {
+  // ◊ô◊¶◊ô◊®◊™ topic ◊ó◊ì◊©
+  const topic = createTopic(topicTitle, source, hubMeta);
 
   const rows = csvText.split(/\r?\n/);
 
   rows.forEach((line) => {
     if (!line.trim()) return;
 
     const p = line.split(",");
-    if (p.length >= 2) {
-      topic.words.push({
-        id: crypto.randomUUID(),
-        learn: p[0].replace(/"/g, "").trim(),
-        tr: p.slice(1).join(",").replace(/"/g, "").trim(),
-      });
-    }
-  });
+    if (p.length >= 2) {
+      topic.words.push({
+        id: uuid(),
+        learn: p[0].replace(/"/g, "").trim(),
+        tr: p.slice(1).join(",").replace(/"/g, "").trim(),
+      });
+    }
+  });
 
   if (topic.words.length === 0) {
     alert("File contains no valid words");
     return false;
   }
 
-  data.topics[topic.id] = topic;
-
-  save();
-  loadTopics();
+  data.topics[topic.id] = topic;
+
+  saveData();
+  loadTopics();
 
   return topic.id;
 }
 
       /* ===== NAV ===== */
       function show(id) {
         document
           .querySelectorAll(".screen")
           .forEach((s) => s.classList.remove("active"));
         document.getElementById(id).classList.add("active");
       }
 
       function showBank() {
         resetBankSearch();
         loadTopics();
         show("bank");
       }
 
       function showStats() {
         renderStats();
         show("stats");
       }
       function showContact() {
         show("contact");
       }
@@ -1391,82 +1411,82 @@ function isTopicTitleTaken(title, excludeId = null) {
 
         if (!entries.length) {
           wordList.innerHTML = "<p>No hard words.</p>";
           return;
         }
 
         entries.forEach(([key, count], i) => {
           const [learn, tr] = key.split("||");
 
           wordList.innerHTML += `
       <div class="list-item">
         <div class="word-line">
           ${i + 1}. ${learn} ‚Äì ${tr}
         </div>
         <div class="actions">
           <button style="font-size:12px;padding:6px;"
             onclick="removeHardWord('${key.replace(/'/g, "\\'")}')">
             Remove
           </button>
           <span style="opacity:.6;font-size:12px;">${count}√ó</span>
         </div>
       </div>`;
         });
       }
 
-      function removeHardWord(key) {
-        if (!stats.hardWords[key]) return;
-
-        delete stats.hardWords[key];
-        save();
-
-        renderHardWordsList();
-      }
+      function removeHardWord(key) {
+        if (!stats.hardWords[key]) return;
+
+        delete stats.hardWords[key];
+        saveStats();
+
+        renderHardWordsList();
+      }
 
       function renameCurrentTopic() {
   if (!currentTopic || currentTopic === "Hard Words") return;
 
   const topic = data.topics[currentTopic];
   if (!topic) return;
 
   const input = prompt("New topic name:", topic.title);
   if (!input) return;
 
   const newTitle = input.trim();
   if (!newTitle) return;
 
-  if (isTopicTitleTaken(newTitle, topic.id)) {
-    alert("Topic with this name already exists.");
-    return;
-  }
+  if (!isTopicTitleAvailable(newTitle, topic.id)) {
+    alert("Topic with this name already exists.");
+    return;
+  }
 
   topic.title = newTitle;
 
-  save();
-  loadTopics();
-  renderWordList();
-}
+  saveData();
+  loadTopics();
+  renderWordList();
+}
 
 
       function addWordToCurrentTopic() {
         if (!currentTopic) return;
 
         lastAddTopic = currentTopic;
         showAdd();
       }
 
       bankTopicSelect.onchange = () => {
         if (!bankTopicSelect.value) return;
         setCurrentTopic(bankTopicSelect.value);
         deleteTopicBtn.classList.toggle("hidden", currentTopic === "All words");
 
         resetBankSearch();
         renderWordList();
         show("bankList");
       };
 
       function renderWordList() {
   const topic = data.topics[currentTopic];
   if (!topic) return;
 
   let q = searchInput.value.toLowerCase();
   let sort = sortSelect.value;
@@ -1495,89 +1515,95 @@ function isTopicTitleTaken(title, excludeId = null) {
       <div class="list-item">
         <div class="word-line">
           ${i + 1}. ${w.learn} ‚Äì ${w.tr}
         </div>
         <div class="actions">
           <button style="font-size:12px;padding:6px;" onclick="editWord('${w.id}')">Edit</button>
           <button style="font-size:12px;padding:6px;" onclick="deleteWord('${w.id}')">Delete</button>
         </div>
       </div>`;
   });
 }
 
       function exportCurrentTopic() {
         let rows = ["Learning language,Translation"];
         data.topics[currentTopic].forEach((w) =>
           rows.push(`"${w.learn}","${w.tr}"`),
         );
         let blob = new Blob([rows.join("\n")], { type: "text/csv" });
         let a = document.createElement("a");
         a.href = URL.createObjectURL(blob);
         a.download = `${currentTopic}.csv`;
         a.click();
       }
 
       function deleteCurrentTopic() {
-        if (confirm("Delete this topic and all its words?")) {
-          delete data.topics[currentTopic];
-          save();
-          showBank();
-        }
-      }
+        if (confirm("Delete this topic and all its words?")) {
+          delete data.topics[currentTopic];
+          saveData();
+          showBank();
+        }
+      }
 
       function deleteWord(id) {
-  const topic = data.topics[currentTopic];
-  if (!topic) return;
-
-  topic.words = topic.words.filter((w) => w.id !== id);
-  save();
-  renderWordList();
-}
+  const topic = data.topics[currentTopic];
+  if (!topic) {
+    console.warn("No topic found for deleteWord.");
+    return;
+  }
+
+  topic.words = topic.words.filter((w) => w.id !== id);
+  saveData();
+  renderWordList();
+}
 
 
    function editWord(id) {
-  const topic = data.topics[currentTopic];
-  if (!topic) return;
+  const topic = data.topics[currentTopic];
+  if (!topic) {
+    console.warn("No topic found for editWord.");
+    return;
+  }
 
   // ◊ñ◊ï◊õ◊®◊ô◊ù ◊ú◊ê◊ü ◊ú◊ó◊ñ◊ï◊®
   returnToTopicAfterSave = currentTopic;
 
   const w = topic.words.find((x) => x.id === id);
   if (!w) return;
 
   // ◊û◊°◊ô◊®◊ô◊ù ◊ñ◊û◊†◊ô◊™
   topic.words = topic.words.filter((x) => x.id !== id);
 
   showAdd();
   addTopicSelect.value = currentTopic;
   onAddTopicChange();
 
-  learnInput.value = w.learn;
-  translationInput.value = w.tr;
-
-  save();
-}
+  learnInput.value = w.learn;
+  translationInput.value = w.tr;
+
+  saveData();
+}
 
 
 
   /* ===== ADD WORD ===== */
 
       function showAdd() {
         resetBankSearch();
 
         learnInput.value = "";
         translationInput.value = "";
         newTopicInput.value = "";
         newTopicInput.disabled = true;
         newTopicInput.classList.add("hidden");
 
         loadAddTopics();
         show("add");
       }
 
       function loadAddTopics() {
         addTopicSelect.innerHTML = "";
 
         addTopicSelect.innerHTML += `<option value="">Select topic</option>`;
         addTopicSelect.innerHTML += `<option value="_new">+ New topic</option>`;
 
         Object.values(data.topics).forEach((t) => {
@@ -1590,165 +1616,174 @@ function isTopicTitleTaken(title, excludeId = null) {
         } else {
           addTopicSelect.value = "";
         }
 
         onAddTopicChange();
       }
 
       function onAddTopicChange() {
         const isNew = addTopicSelect.value === "_new";
 
         newTopicInput.disabled = !isNew;
         newTopicInput.classList.toggle("hidden", !isNew);
 
         if (!isNew) {
           newTopicInput.value = "";
         }
       }
 
   function saveWord() {
   const isNewTopic = addTopicSelect.value === "_new";
 
   const topicTitle = isNewTopic
     ? newTopicInput.value.trim()
     : data.topics[addTopicSelect.value]?.title;
 
-  if (!topicTitle) return;
-  if (!learnInput.value || !translationInput.value) return;
+  if (!topicTitle) {
+    console.warn("Missing topic title for saveWord.");
+    return;
+  }
+  if (!learnInput.value || !translationInput.value) {
+    console.warn("Missing learn/translation value for saveWord.");
+    return;
+  }
 
   let topicId;
 
   // ----- ◊ô◊¶◊ô◊®◊™ Topic ◊ó◊ì◊© -----
-  if (isNewTopic) {
-    if (isTopicTitleTaken(topicTitle)) {
-      alert("Topic with this name already exists.");
-      return;
-    }
+  if (isNewTopic) {
+    if (!isTopicTitleAvailable(topicTitle)) {
+      alert("Topic with this name already exists.");
+      return;
+    }
 
     const topic = createTopic(topicTitle, "local");
     data.topics[topic.id] = topic;
     topicId = topic.id;
   } 
   // ----- Topic ◊ß◊ô◊ô◊ù -----
   else {
     topicId = addTopicSelect.value;
   }
 
-  const topic = data.topics[topicId];
-  if (!topic) return;
+  const topic = data.topics[topicId];
+  if (!topic) {
+    console.warn("No topic found for saveWord.");
+    return;
+  }
 
   // ◊î◊ï◊°◊§◊™ ◊û◊ô◊ú◊î
-  topic.words.push({
-    id: crypto.randomUUID(),
-    learn: learnInput.value,
-    tr: translationInput.value,
-  });
-
-  save();
-  loadTopics();
-  updateInstructions();
+  topic.words.push({
+    id: uuid(),
+    learn: learnInput.value,
+    tr: translationInput.value,
+  });
+
+  saveData();
+  loadTopics();
+  updateInstructions();
 
   // ◊†◊ô◊ß◊ï◊ô ◊©◊ì◊ï◊™
   learnInput.value = "";
   translationInput.value = "";
   newTopicInput.value = "";
 
   // ----- ◊ó◊ñ◊®◊î ◊ú◊®◊©◊ô◊û◊î ◊ê◊ó◊®◊ô ◊¢◊®◊ô◊õ◊î -----
   if (returnToTopicAfterSave) {
     setCurrentTopic(returnToTopicAfterSave);
     returnToTopicAfterSave = null;
     show("bankList");
     renderWordList();
     return;
   }
 
   // ----- ◊û◊¶◊ë ◊®◊í◊ô◊ú: ◊†◊©◊ê◊®◊ô◊ù ◊ë-ADD -----
   setCurrentTopic(topicId);
   loadAddTopics();
   addTopicSelect.value = topicId;
   onAddTopicChange();
 }
 
 
 
       /* ===== IMPORT ===== */
 
       function triggerImport() {
         importFile.click();
       }
 
       importFile.onchange = (e) => {
   const file = e.target.files[0];
   if (!file) {
     importFile.value = "";
     return;
   }
 
   const baseTitle = file.name.replace(/\.[^/.]+$/, "").trim();
   if (!baseTitle) {
     alert("Invalid file name");
     importFile.value = "";
     return;
   }
 
-  if (isTopicTitleTaken(baseTitle)) {
-    alert("Topic with this name already exists.");
-    importFile.value = "";
-    return;
-  }
+  if (!isTopicTitleAvailable(baseTitle)) {
+    alert("Topic with this name already exists.");
+    importFile.value = "";
+    return;
+  }
 
   const reader = new FileReader();
   reader.onload = (ev) => {
     const csvText = ev.target.result;
 
     const topic = createTopic(baseTitle, "local");
     const rows = csvText.split(/\r?\n/);
 
     rows.forEach((line, i) => {
       if (!line.trim()) return;
 
       const p = line.split(",");
-      if (p.length >= 2) {
-        topic.words.push({
-          id: crypto.randomUUID(),
-          learn: p[0].replace(/"/g, "").trim(),
-          tr: p.slice(1).join(",").replace(/"/g, "").trim(),
-        });
-      }
+      if (p.length >= 2) {
+        topic.words.push({
+          id: uuid(),
+          learn: p[0].replace(/"/g, "").trim(),
+          tr: p.slice(1).join(",").replace(/"/g, "").trim(),
+        });
+      }
     });
 
     if (topic.words.length === 0) {
       alert("File contains no valid words");
       importFile.value = "";
       return;
     }
 
-    data.topics[topic.id] = topic;
-
-    save();
-    loadTopics();
-    updateInstructions();
+    data.topics[topic.id] = topic;
+
+    saveData();
+    loadTopics();
+    updateInstructions();
 
     setCurrentTopic(topic.id);
     importFile.value = "";
 
     startSessionSafe(topic.id);
   };
 
   reader.readAsText(file, "UTF-8");
 };
 
       /* ===== SESSION ===== */
 
       // session state (single source of truth)
       let session = [];
       let current = null;
       let cardFlipped = false;
       let shuffleUsed = false;
       let sessionDefaultDirection = "A";
 
       function exitSessionSafe(nextScreen) {
         if (stats.current) {
           finishSessionIfActive();
         }
 
         if (nextScreen) {
@@ -1822,51 +1857,51 @@ function isTopicTitleTaken(title, excludeId = null) {
 
   // ----- START SESSION -----
   shuffleBtn.classList.remove("hidden");
 
   stats.sessions++;
   stats.current = {
     topic: currentTopic,
     correct: 0,
     wrong: 0,
   };
 
   nextCard();
 }
 
 
 function nextCard() {
   if (session.length === 0) {
     stats.history.push(stats.current);
     stats.history = stats.history.slice(-10);
 
     const t = stats.current.topic;
     if (!stats.perTopic[t]) stats.perTopic[t] = { correct: 0, wrong: 0 };
     stats.perTopic[t].correct += stats.current.correct;
     stats.perTopic[t].wrong += stats.current.wrong;
 
-    save();
+    saveStats();
     show("sessionEnd");
     return;
   }
 
   current = session[0];
   cardFlipped = false;
   renderCard();
   show("session");
 }
 
 
       function renderCard() {
         let side = cardFlipped
           ? sessionDefaultDirection === "A"
             ? "B"
             : "A"
           : sessionDefaultDirection;
 
         const text = side === "A" ? current.learn : current.tr;
         card.textContent = text;
 
         requestAnimationFrame(() => {
           autoFitCardText();
         });
 
@@ -1934,51 +1969,51 @@ function nextCard() {
 
       function markUnknown() {
         stats.current.wrong++;
         let key = current.learn + "||" + current.tr;
         stats.hardWords[key] = (stats.hardWords[key] || 0) + 1;
         session.push(session.shift());
         nextCard();
       }
 
       function finishSessionIfActive() {
         if (!stats.current) return;
 
         stats.history.push(stats.current);
 
         stats.history = stats.history.slice(-10);
 
         const t = stats.current.topic;
         if (!stats.perTopic[t]) {
           stats.perTopic[t] = { correct: 0, wrong: 0 };
         }
 
         stats.perTopic[t].correct += stats.current.correct;
         stats.perTopic[t].wrong += stats.current.wrong;
 
         stats.current = null;
-        save();
+        saveStats();
       }
 
       function loadCSVToSession(csvText, topicTitle) {
         session = [];
 
         csvText.split(/\r?\n/).forEach((line, i) => {
           if (i === 0) return;
           const p = line.split(",");
           if (p.length >= 2) {
             session.push({
               learn: p[0].replace(/"/g, ""),
               tr: p.slice(1).join(",").replace(/"/g, ""),
             });
           }
         });
 
         if (session.length === 0) return;
 
         setCurrentTopic(topicTitle);
         sessionDefaultDirection = "A";
         cardFlipped = false;
         shuffleUsed = false;
 
         stats.sessions++;
         stats.current = { topic: currentTopic, correct: 0, wrong: 0 };
@@ -2042,51 +2077,51 @@ function nextCard() {
                     </button>
                   </td>
                 </tr>`;
             })
             .join("")}
         </tbody>
       </table>`
           : `<h3>Hard Words</h3><p>No hard words</p>`;
 
         statsContent.innerHTML = `
     <p>Topics: ${topics}</p>
     <p>Words: ${words}</p>
     <p>Sessions started: ${stats.sessions}</p>
     <hr>
     <h3>By topic</h3>
     ${topicStats || "<p>No data</p>"}
     <hr>
     ${hardTable}
   `;
       }
 
       function removeHardWord(key) {
         if (!stats.hardWords[key]) return;
 
         delete stats.hardWords[key];
-        save();
+        saveStats();
         renderStats();
       }
 
       function resetStats() {
         if (!confirm("Reset ALL statistics?")) return;
 
         stats = {
           sessions: 0,
           history: [],
           perTopic: {},
           hardWords: {},
         };
 
         localStorage.setItem(STATS_KEY, JSON.stringify(stats));
 
         renderStats();
       }
 
       /* ===== MISC ===== */
 
       /* == reset == */
       async function hardReset() {
         localStorage.clear();
 
         if ("caches" in window) {
@@ -2320,26 +2355,26 @@ const topicTitle = `${groupId} ¬∑ ${baseName} (${fileName})`;
 
       /* ===== INIT (SAFE) ===== */
 
 const APP_VERSION = 555;
 const APP_VERSION_KEY = "app_version";
 
 (function bootstrapVersionGate() {
   const stored = Number(localStorage.getItem(APP_VERSION_KEY));
 
   if (stored !== APP_VERSION) {
     localStorage.clear();
     localStorage.setItem(APP_VERSION_KEY, APP_VERSION);
     localStorage.setItem(RESET_FLAG, "1");
   }
 })();
 
 (function startApp() {
   gateUntilReset(); // ◊ê◊ù ◊î◊ó◊ú◊ò◊™ ◊ú◊î◊©◊ê◊ô◊® ◊ê◊ï◊™◊ï
   loadHubIndex();
   loadTopics();
   updateInstructions();
 })();
 
     </script>
   </body>
-</html>
\ No newline at end of file
+</html>
