<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hebrew with MotiVation</title>
<style>
/* ===== RESET ===== */
* {
  box-sizing: border-box;
}

.hidden {
  display: none;
}

/* ===== BODY ===== */
body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
    Roboto, Helvetica, Arial, sans-serif;
  background: #111;
  color: #fff;
  font-size: 17px;
  line-height: 1.55;
  letter-spacing: 0.3px;
  overflow-y: auto;
  overscroll-behavior: none;
}

/* ===== SCREENS ===== */
.screen {
  display: none;
  padding: 18px;
  max-width: 420px;
  margin: auto;
  min-height: 100vh;
  overflow-y: auto;
}

.screen.active {
  display: block;
}

/* ===== HOME ===== */
.welcome {
  font-size: 40px;
  font-weight: 800;
  text-align: center;
  margin-top: 35px;
}

.instructions {
  text-align: center;
  font-size: 25px;
  margin: 20px 0 30px;
  color: #bbb;
}

.title-bottom {
  text-align: center;
  font-size: 30px;
  margin-top: 28px;
  opacity: 0.85;
}

/* ===== BUTTONS (BASE) ===== */
button {
  width: 100%;
  padding: 14px;
  margin: 8px 0;
  font-size: 17px;
  font-weight: 600;
  letter-spacing: 0.3px;
  border: none;
  border-radius: 14px;
  cursor: pointer;
  background: linear-gradient(180deg, #f1f4f8, #dfe7f1);
  color: #222;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
  transition: transform 0.1s, box-shadow 0.1s, background 0.2s;
}

button:hover {
  background: linear-gradient(180deg, #ffffff, #e6eef8);
}

button:active {
  transform: translateY(2px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.35);
}

/* ===== BUTTON VARIANTS ===== */
.forest {
  background: linear-gradient(180deg, #bbf7d0, #22c55e);
  color: #052e16;
}

.back {
  background: linear-gradient(180deg, #e0e0e0, #cfcfcf);
}

.button-danger {
  background: linear-gradient(180deg, #ff9aa2, #ff6f6f);
  color: #300;
}

.button-primary {
  background: linear-gradient(180deg, #9fc5ff, #6fa8ff);
  color: #002b5c;
}

.button-success,
.button-bank {
  background: linear-gradient(180deg, #b7e4c7, #95d5b2);
  color: #103b24;
}

.peach {
  background: linear-gradient(180deg, #ffe5d9, #ffb4a2);
  color: #5a1f14;
}

.sunset {
  background: linear-gradient(180deg, #ffedd5, #fb923c);
  color: #4a1d00;
}

.lavender {
  background: linear-gradient(180deg, #ede9fe, #c4b5fd);
  color: #2e1065;
}

/* ===== FORM ===== */
select,
input,
textarea {
  width: 100%;
  padding: 13px;
  margin: 8px 0;
  font-size: 17px;
  border-radius: 10px;
  border: none;
}

/* ===== SESSION ===== */
#session {
  padding: 12px;
}

.flip-hint {
  text-align: center;
  font-family: "Comic Sans MS", "Trebuchet MS", cursive;
  font-size: 30px;
  margin-bottom: 10px;
  color: #ffd966;
}

.card-frame {
  border: 5px solid #6fa8dc;
  border-radius: 18px;
  padding: 14px;
  background: #2a2a2a;
  box-shadow:
    0 10px 18px rgba(0, 0, 0, 0.6),
    inset 0 0 0 2px rgba(255, 255, 255, 0.08);
}

.card {
  background: #111;
  height: 220px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 102px;
  line-height: 1.15;
  text-align: center;
  border-radius: 12px;
  padding: 20px;
  user-select: none;
  overflow: hidden;
  white-space: normal;
  word-break: normal;
  overflow-wrap: normal;
}

.remaining {
  text-align: center;
  font-size: 20px;
  margin-top: 10px;
  color: #cfe2f3;
}

.row {
  display: flex;
  gap: 10px;
  margin-top: 14px;
}

.row button {
  width: 50%;
}

/* ===== SESSION BUTTONS ===== */
.session-buttons button {
  border-radius: 14px;
  padding: 14px 18px;
  font-size: 16px;
  font-weight: 600;
  color: #ffffff;
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18);
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.session-buttons button:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 26px rgba(0, 0, 0, 0.22);
}

.session-buttons button:active {
  transform: scale(0.97);
}

#knownBtn {
  background: #22c55e;
}

#unknownBtn {
  background: #ef4444;
}

/* ===== BANK / LIST ===== */
#bankListTopicSelect {
  width: 100%;
  padding: 12px;
  margin-bottom: 10px;
  font-size: 16px;
  border-radius: 10px;
  border: none;
  position: relative;
  z-index: 10;
}

.list-item {
  background: #222;
  padding: 17px;
  margin: 8px 0;
  border-radius: 10px;
}

.word-line {
  font-size: 33px;
  font-weight: 600;
  line-height: 1.3;
}

.actions {
  display: flex;
  gap: 8px;
}

.actions button {
  width: 50%;
}

/* ===== STATS ===== */
.stat-block {
  background: #1c1c1c;
  padding: 10px;
  margin: 8px 0;
  border-radius: 10px;
}

/* ===== CONTACT ===== */
.contact button {
  background: linear-gradient(180deg, #e6e6e6, #efcfcf);
  color: #222;
  font-weight: 700;
}

/* ===== SOUND ===== */
.sound-toggle {
  text-align: center;
  font-size: 22px;
  margin: 10px 0 6px;
  cursor: pointer;
  user-select: none;
  opacity: 0.85;
}

.sound-toggle:hover {
  opacity: 1;
}
</style>

  </head>

  <body>
    <!-- HOME -->
    <div class="screen active" id="home">
      <div class="welcome">WELCOME</div>
      <br />

      <div id="instructions" class="instructions">
        To start, add words OR load a file in the Word Bank
      </div>

      <select id="topicSelect"></select>
      <button
        class="button-primary"
        onclick="startSessionSafe(topicSelect.value)"
      >
        Start Session
      </button>

      <button class="peach" onclick="showBank()">Word Bank</button>
      <button class="lavender" onclick="showStats()">Statistics</button>
      <button class="forest" onclick="showContact()">Contact</button>
      <button onclick="exitApp()" class="back">Exit</button>

      <div class="title-bottom">Hebrew with MotiVation</div>
      <div style="text-align: center; opacity: 0.4">TEST - 79</div>

      <div
        id="cacheVersion"
        style="
          text-align: center;
          font-size: 13px;
          opacity: 0.5;
          margin-top: 20px;
        "
      ></div>
    </div>

    <!-- RESET -->
    <div class="screen" id="resetGate">
      <h2>Update</h2>

      <button class="SUNSET" onclick="hardReset()">Reset App</button>
    </div>

    <!-- BANK -->
    <div class="screen" id="bank">
      <h2>Word Bank</h2>
      <select id="bankTopicSelect"></select>
      <button class="sunset" onclick="showAdd()">Add words / topic</button>

      <div class="word-files-invite">
        <button class="invite-cta" onclick="showDownload()">
          Word Library
        </button>
      </div>

      <button class="peach" onclick="triggerImport()">Import word file</button>

      <button onclick="goHome()" class="back">Back</button>
    </div>

    <!-- ACCORDIONS  -->
    <div class="screen" id="download">
      <h2>WORD LIBRARY</h2>

      <div class="download-lang-box">
        <div class="download-lang-title">Choose language</div>

        <select id="downloadLangSelect">
          <option value="" hidden>Choose language pair</option>
          <option value="he-en">Hebrew ‚Üí English</option>
          <option value="pl-en">Polish ‚Üí English</option>
          <option value="ar-he">Arabic ‚Üí Hebrew</option>
          <option value="es-he">Spanish ‚Üí Hebrew</option>
        </select>
      </div>

      <div class="download-divider"></div>

      <div class="download-topics-title">Choose topic</div>

      <div id="downloadAccordions"></div>

      <button class="back" onclick="goHome()">Back</button>
    </div>

    <!-- BANK LIST -->

    <div class="screen" id="bankList">
      <select
        id="bankListTopicSelect"
        onchange="switchBankListTopic()"
      ></select>

      <button onclick="addWordToCurrentTopic()" class="forest">
        + Add word
      </button>

      <button class="lavender" onclick="exportCurrentTopic()">
        Export word file
      </button>

      <div style="display: flex; gap: 8px">
        <button class="peach" style="flex: 1" onclick="renameCurrentTopic()">
          Rename
        </button>
        <button
          id="deleteTopicBtn"
          class="button-danger"
          style="flex: 1"
          onclick="deleteCurrentTopic()"
        >
          Delete
        </button>
      </div>

      <button class="back" style="font-weight: 700" onclick="goHome()">
        Back
      </button>

      <input
        id="searchInput"
        placeholder="Search..."
        oninput="renderWordList()"
      />
      <select id="sortSelect" onchange="renderWordList()">
        <option value="">No sorting</option>
        <option value="learn">By learning language</option>
        <option value="tr">By translation</option>
      </select>

      <div id="wordList"></div>

      <button onclick="showBank()" class="back">Back</button>
    </div>

    <!-- ADD -->
    <div class="screen" id="add">
      <h2>Add word</h2>
      <select id="addTopicSelect" onchange="onAddTopicChange()"></select>
      <input id="newTopicInput" class="hidden" placeholder="New topic name" />
      <textarea id="learnInput" placeholder="Learning language"></textarea>
      <textarea id="translationInput" placeholder="Translation"></textarea>
      <button class="forest" onclick="saveWord()">Save</button>
      <button onclick="goHome()" class="back">Back</button>
    </div>

    <!-- SESSION -->
    <div class="screen" id="session">
      <div class="flip-hint">CLICK TO FLIP</div>

      <div class="card-frame">
        <div class="card" id="card" onclick="flipCard()"></div>
      </div>

      <div class="remaining">Remaining: <span id="remainingCount"></span></div>

      <div class="sound-toggle" onclick="toggleSound()" id="soundIcon">üîä</div>

      <div class="row">
        <button class="forest" onclick="markKnown()">I knew it</button>
        <button class="button-danger" onclick="markUnknown()">Ooooopsi</button>
      </div>

      <button class="lavender" id="shuffleBtn" onclick="shuffleSession()">
        Shuffle
      </button>
      <button class="sunset" onclick="flipDirection()">Flip Direction</button>
      <button onclick="exitSessionSafe('home')" class="back">Exit</button>
    </div>

    <!-- SESSION END -->
    <div class="screen" id="sessionEnd">
      <div class="session-end-box">
        <h1>üéâ Well done üéâ</h1>
        <p class="session-end-sub">You‚Äôve completed the session</p>

        <button class="forest" id="restartSessionBtn">Start again</button>

        <button onclick="exitSessionSafe('home')" class="back">Exit</button>
      </div>
    </div>

    <!-- STATS -->
    <div class="screen" id="stats">
      <button onclick="resetStats()" class="button-danger">
        Reset statistics
      </button>
      <button onclick="goHome()" class="back">Back</button>
      <div id="statsContent"></div>
      <button onclick="goHome()" class="back">Back</button>
    </div>

    <!-- CONTACT -->
    <div class="screen contact" id="contact">
      <div class="about-box">
        <div class="about-title">Hebrew with Moti Vation</div>

        <p>
          I'm here ‚Äì No Fear<br />
          Hebrew will become so clear
        </p>

        <p>
          Online sessions from the comfort of your home<br />
          Beginners / Advanced / Individuals / Groups
        </p>

        <p>
          Fun & Interesting lessons<br />
          I love languages and I love teaching
        </p>

        <p>
          Lets go on adventure..<br />
          Cake Eat Easy<br />
          Take care ‚Äì Take air
        </p>
      </div>

      <div class="contact-links">
        <a
          class="facebook"
          href="https://www.facebook.com/share/1D6uJLL5nK/"
          target="_blank"
        >
          Facebook
        </a>

        <a
          class="instagram"
          href="https://www.instagram.com/hebrew_with_motivation"
          target="_blank"
        >
          Instagram
        </a>

        <a class="email" href="mailto:mottex@gmail.com"> Email </a>

        <a class="whatsapp" href="https://wa.me/48604726360" target="_blank">
          WhatsApp
        </a>
      </div>

      <button onclick="goHome()" class="back">Back</button>
    </div>

    <input type="file" id="importFile" accept=".csv" class="hidden" />

    <script src="hubIndex.js?v=555"></script>

    <script>
      /* ===== STORAGE CONSTANTS ===== */
      const STORAGE_VERSION = "v555";
      const FLASH_KEY = `flashData_${STORAGE_VERSION}`;
      const STATS_KEY = `stats_${STORAGE_VERSION}`;
      const RESET_FLAG = "APP_RESET_DONE_v555";

      if ("scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }

      /* ===== SOUND ===== */

      let soundOn = JSON.parse(localStorage.getItem("soundOn") ?? "true");
      // very soft sounds

      const flipSound = new Audio(
        "https://actions.google.com/sounds/v1/impacts/metal_parts_cling.ogg",
      );
      const correctSound = new Audio(
        "https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg",
      );

      flipSound.volume = 0.2;
      correctSound.volume = 0.07;

      function toggleSound() {
        soundOn = !soundOn;
        localStorage.setItem("soundOn", JSON.stringify(soundOn));
        updateSoundIcon();
      }

      function updateSoundIcon() {
        const el = document.getElementById("soundIcon");
        if (el) el.textContent = soundOn ? "üîä" : "üîá";
      }

      /* ===== DATA ===== */

let returnToTopicAfterSave = null;

function createTopic(title, source = "local", hubMeta = null) {
  return {
    id: crypto.randomUUID(),
    title,
    source,
    hubMeta,
    words: []
  };
}

let data = JSON.parse(localStorage.getItem(FLASH_KEY)) || {
  topics: {} // topicId -> { id, title, source, hubMeta, words }
};

      let stats = JSON.parse(localStorage.getItem(STATS_KEY)) || {
        sessions: 0,
        history: [],
        perTopic: {},
        hardWords: {},
      };

      const topicSelect = document.getElementById("topicSelect");

      topicSelect.onchange = function () {
        setCurrentTopic(this.value);
      };

      const bankTopicSelect = document.getElementById("bankTopicSelect");
      const bankListTopicSelect = document.getElementById(
        "bankListTopicSelect",
      );
      bankListTopicSelect.onchange = switchBankListTopic;

      const searchInput = document.getElementById("searchInput");
      const sortSelect = document.getElementById("sortSelect");
      const wordList = document.getElementById("wordList");
      const addTopicSelect = document.getElementById("addTopicSelect");
      const learnInput = document.getElementById("learnInput");
      const translationInput = document.getElementById("translationInput");
      const newTopicInput = document.getElementById("newTopicInput");
      const importFile = document.getElementById("importFile");
      const shuffleBtn = document.getElementById("shuffleBtn");
      const card = document.getElementById("card");

let lastAddTopic = null;


      /* ===== HUB INDEX ===== */

      // state (HUB is read-only)
      let hubIndex = null;
      let currentTopic = null;

      /*
Expected structure:
{
  version: number,
  languages: [{ id, title }],
  branches: [{ id, title }],
  entries: [
    {
      branch: string,
      group: string,
      files: { [lang]: string[] }
    }
  ]
}
*/

      function loadHubIndex() {
        if (!window.HUB_INDEX) {
          alert("Word Library is not available right now.");
          return false;
        }

        const idx = window.HUB_INDEX;

        // basic shape validation
        if (
          typeof idx !== "object" ||
          !Array.isArray(idx.languages) ||
          !Array.isArray(idx.branches) ||
          !Array.isArray(idx.entries)
        ) {
          alert("Word Library is corrupted.");
          return false;
        }

        hubIndex = idx;
        return true;
      }

      /* ===== UTIL ===== */

      function save() {
        localStorage.setItem(FLASH_KEY, JSON.stringify(data));
        localStorage.setItem(STATS_KEY, JSON.stringify(stats));
      }

      function setCurrentTopic(topicId) {
  currentTopic = topicId || null;

  if (topicSelect) topicSelect.value = topicId || "";
  if (bankTopicSelect) bankTopicSelect.value = topicId || "";
  if (bankListTopicSelect) bankListTopicSelect.value = topicId || "";
}


      /* ===== TOPIC NAME GATE ===== */

      function normalizeTopicName(name) {
        return name
          .trim()
          .replace(/\s+/g, " ") // ◊®◊ï◊ï◊ó◊ô◊ù ◊õ◊§◊ï◊ú◊ô◊ù ‚Üí ◊®◊ï◊ï◊ó ◊ê◊ó◊ì
          .toLowerCase(); // ◊ë◊ú◊ô ◊î◊ë◊ì◊ú ◊ê◊ï◊™◊ô◊ï◊™
      }

      /*
mode:
- "create"  ‚Üí ◊ô◊¶◊ô◊®◊™ ◊ò◊ï◊§◊ô◊ß ◊ó◊ì◊© (ADD / IMPORT / DOWNLOAD)
- "rename"  ‚Üí ◊©◊ô◊†◊ï◊ô ◊©◊ù ◊ò◊ï◊§◊ô◊ß
*/


function isTopicTitleTaken(title, excludeId = null) {
  const norm = normalizeTopicName(title);

  return Object.values(data.topics).some((t) => {
    if (excludeId && t.id === excludeId) return false;
    return normalizeTopicName(t.title) === norm;
  });
}

      function validateTopicName(name, mode, currentName = null) {
        const n = normalizeTopicName(name);

        if (!n) {
          alert("Topic name is empty");
          return null;
        }

        // ◊ô◊¶◊ô◊®◊™ ◊ò◊ï◊§◊ô◊ß ◊ó◊ì◊©
        if (mode === "create") {
          if (data.topics[n]) {
            alert(`Topic "${n}" already exists`);
            return null;
          }
          return n;
        }

        // ◊©◊ô◊†◊ï◊ô ◊©◊ù
        if (mode === "rename") {
          if (n === currentName) return n; // ◊ê◊ï◊™◊ï ◊©◊ù ‚Äì ◊û◊ï◊™◊®
          if (data.topics[n]) {
            alert(`Topic "${n}" already exists`);
            return null;
          }
          return n;
        }

        console.error("Unknown topic name validation mode:", mode);
        return null;
      }

      function allWords() {
  let a = [];
  Object.values(data.topics).forEach((topic) => {
    a.push(...topic.words);
  });
  return a;
}


      /* ===== LIBRARY ‚Üí FC TOPIC ===== */
      function saveCSVAsTopic(csvText, topicTitle, source = "hub", hubMeta = null) {
  // ◊ô◊¶◊ô◊®◊™ topic ◊ó◊ì◊©
  const topic = createTopic(topicTitle, source, hubMeta);

  const rows = csvText.split(/\r?\n/);

  rows.forEach((line) => {
    if (!line.trim()) return;

    const p = line.split(",");
    if (p.length >= 2) {
      topic.words.push({
        id: crypto.randomUUID(),
        learn: p[0].replace(/"/g, "").trim(),
        tr: p.slice(1).join(",").replace(/"/g, "").trim(),
      });
    }
  });

  if (topic.words.length === 0) {
    alert("File contains no valid words");
    return false;
  }

  data.topics[topic.id] = topic;

  save();
  loadTopics();

  return topic.id;
}

      /* ===== NAV ===== */
      function show(id) {
        document
          .querySelectorAll(".screen")
          .forEach((s) => s.classList.remove("active"));
        document.getElementById(id).classList.add("active");
      }

      function showBank() {
        resetBankSearch();
        loadTopics();
        show("bank");
      }

      function showStats() {
        renderStats();
        show("stats");
      }
      function showContact() {
        show("contact");
      }

      function showDownload() {
        if (stats.current) {
          exitSessionSafe("download");
          return;
        }

        if (!hubIndex) return;

        // ◊ê◊ô◊§◊ï◊° ◊©◊§◊î
        currentDownloadLang = null;

        // ◊ê◊ô◊§◊ï◊° ◊ë◊ó◊ô◊®◊î ◊ï◊°◊ò◊ô◊ô◊ú ◊©◊ú ◊î◊©◊§◊î
        if (downloadLangSelect) {
          downloadLangSelect.value = "";
        }

        // ◊ë◊†◊ô◊ô◊™ UI ◊©◊ú ◊î◊ê◊ß◊ï◊®◊ì◊ô◊ï◊†◊ô◊ù
        buildDownloadUI();

        // ◊û◊¶◊ë ◊ê◊§◊ï◊® ‚Äì ◊†◊ï◊©◊ê◊ô◊ù ◊†◊¢◊ï◊ú◊ô◊ù ◊¢◊ì ◊ë◊ó◊ô◊®◊™ ◊©◊§◊î
        const acc = document.getElementById("downloadAccordions");
        if (acc) {
          acc.classList.add("lang-not-selected");
        }

        // ◊¢◊ì◊õ◊ï◊ü ◊°◊ò◊ô◊ô◊ú ◊©◊ú select (◊û◊ï◊®◊ô◊ì ◊õ◊ú ◊°◊ô◊û◊ï◊ü ◊ß◊ï◊ì◊ù)
        markActiveDownloadLang();

        // ◊°◊í◊ô◊®◊™ ◊õ◊ú ◊î◊ê◊ß◊ï◊®◊ì◊ô◊ï◊†◊ô◊ù
        closeAllAccordions();

        // ◊î◊¶◊í◊™ ◊î◊û◊°◊ö
        show("download");
      }

      function goHome() {
        resetBankSearch();
        exitSessionSafe("home");
        loadTopics();
        updateInstructions();
      }

      /* ===== HOME LOGIC ===== */
      function updateInstructions() {
        document
          .getElementById("instructions")
          .classList.toggle("hidden", allWords().length > 0);
      }

      /* ===== TOPICS ===== */

      function loadTopics() {
         const hardLabel = "Hard Words";

  const topicList = Object.values(data.topics);
  const isBankEmpty = topicList.length === 0;

  /* ---------- HOME ---------- */
  topicSelect.innerHTML = '<option value="">Select topic</option>';
  topicSelect.innerHTML += `<option>${hardLabel}</option>`;
  topicList.forEach((t) => {
    topicSelect.innerHTML += `<option value="${t.id}">${t.title}</option>`;
  });

  /* ---------- BANK ---------- */
  bankTopicSelect.innerHTML = '<option value="">Select topic</option>';
  topicList.forEach((t) => {
    bankTopicSelect.innerHTML += `<option value="${t.id}">${t.title}</option>`;
  });

  /* ---------- BANK LIST ---------- */
  bankListTopicSelect.innerHTML = "";
  topicList.forEach((t) => {
    bankListTopicSelect.innerHTML += `<option value="${t.id}">${t.title}</option>`;
  });

  if (currentTopic && data.topics[currentTopic]) {
    bankListTopicSelect.value = currentTopic;
  }

  /* ---------- EMPTY BANK GUARD ---------- */
  if (isBankEmpty) {
    topicSelect.disabled = true;
    bankTopicSelect.disabled = true;
    bankListTopicSelect.innerHTML = "";
  } else {
    topicSelect.disabled = false;
    bankTopicSelect.disabled = false;
  }
}


      /* ===== REAL BANK ===== */

      function resetBankSearch() {
        if (searchInput) searchInput.value = "";
        if (sortSelect) sortSelect.value = "";
      }

      function switchBankListTopic() {
  const topicId = bankListTopicSelect.value;
  if (!topicId) return;

  setCurrentTopic(topicId);

  if (topicId === "Hard Words") {
    renderHardWordsList();
    show("bankList");
    return;
  }

  renderWordList();
  show("bankList");
}


      function renderHardWordsList() {
        wordList.innerHTML = "";

        const entries = Object.entries(stats.hardWords)
          .filter((e) => e[1] >= 2)
          .sort((a, b) => b[1] - a[1]);

        if (!entries.length) {
          wordList.innerHTML = "<p>No hard words.</p>";
          return;
        }

        entries.forEach(([key, count], i) => {
          const [learn, tr] = key.split("||");

          wordList.innerHTML += `
      <div class="list-item">
        <div class="word-line">
          ${i + 1}. ${learn} ‚Äì ${tr}
        </div>
        <div class="actions">
          <button style="font-size:12px;padding:6px;"
            onclick="removeHardWord('${key.replace(/'/g, "\\'")}')">
            Remove
          </button>
          <span style="opacity:.6;font-size:12px;">${count}√ó</span>
        </div>
      </div>`;
        });
      }

      function removeHardWord(key) {
        if (!stats.hardWords[key]) return;

        delete stats.hardWords[key];
        save();

        renderHardWordsList();
      }

      function renameCurrentTopic() {
  if (!currentTopic || currentTopic === "Hard Words") return;

  const topic = data.topics[currentTopic];
  if (!topic) return;

  const input = prompt("New topic name:", topic.title);
  if (!input) return;

  const newTitle = input.trim();
  if (!newTitle) return;

  if (isTopicTitleTaken(newTitle, topic.id)) {
    alert("Topic with this name already exists.");
    return;
  }

  topic.title = newTitle;

  save();
  loadTopics();
  renderWordList();
}


      function addWordToCurrentTopic() {
        if (!currentTopic) return;

        lastAddTopic = currentTopic;
        showAdd();
      }

      bankTopicSelect.onchange = () => {
        if (!bankTopicSelect.value) return;
        setCurrentTopic(bankTopicSelect.value);
        deleteTopicBtn.classList.toggle("hidden", currentTopic === "All words");

        resetBankSearch();
        renderWordList();
        show("bankList");
      };

      function renderWordList() {
  const topic = data.topics[currentTopic];
  if (!topic) return;

  let q = searchInput.value.toLowerCase();
  let sort = sortSelect.value;

  wordList.innerHTML = "";

  let arr = [...topic.words];

  if (q) {
    arr = arr.filter(
      (w) =>
        w.learn.toLowerCase().includes(q) ||
        w.tr.toLowerCase().includes(q),
    );
  }

  if (sort === "learn") {
    arr.sort((a, b) => a.learn.localeCompare(b.learn));
  }
  if (sort === "tr") {
    arr.sort((a, b) => a.tr.localeCompare(b.tr));
  }

  arr.forEach((w, i) => {
    wordList.innerHTML += `
      <div class="list-item">
        <div class="word-line">
          ${i + 1}. ${w.learn} ‚Äì ${w.tr}
        </div>
        <div class="actions">
          <button style="font-size:12px;padding:6px;" onclick="editWord('${w.id}')">Edit</button>
          <button style="font-size:12px;padding:6px;" onclick="deleteWord('${w.id}')">Delete</button>
        </div>
      </div>`;
  });
}

      function exportCurrentTopic() {
        let rows = ["Learning language,Translation"];
        data.topics[currentTopic].forEach((w) =>
          rows.push(`"${w.learn}","${w.tr}"`),
        );
        let blob = new Blob([rows.join("\n")], { type: "text/csv" });
        let a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `${currentTopic}.csv`;
        a.click();
      }

      function deleteCurrentTopic() {
        if (confirm("Delete this topic and all its words?")) {
          delete data.topics[currentTopic];
          save();
          showBank();
        }
      }

      function deleteWord(id) {
  const topic = data.topics[currentTopic];
  if (!topic) return;

  topic.words = topic.words.filter((w) => w.id !== id);
  save();
  renderWordList();
}


   function editWord(id) {
  const topic = data.topics[currentTopic];
  if (!topic) return;

  // ◊ñ◊ï◊õ◊®◊ô◊ù ◊ú◊ê◊ü ◊ú◊ó◊ñ◊ï◊®
  returnToTopicAfterSave = currentTopic;

  const w = topic.words.find((x) => x.id === id);
  if (!w) return;

  // ◊û◊°◊ô◊®◊ô◊ù ◊ñ◊û◊†◊ô◊™
  topic.words = topic.words.filter((x) => x.id !== id);

  showAdd();
  addTopicSelect.value = currentTopic;
  onAddTopicChange();

  learnInput.value = w.learn;
  translationInput.value = w.tr;

  save();
}



  /* ===== ADD WORD ===== */

      function showAdd() {
        resetBankSearch();

        learnInput.value = "";
        translationInput.value = "";
        newTopicInput.value = "";
        newTopicInput.disabled = true;
        newTopicInput.classList.add("hidden");

        loadAddTopics();
        show("add");
      }

      function loadAddTopics() {
        addTopicSelect.innerHTML = "";

        addTopicSelect.innerHTML += `<option value="">Select topic</option>`;
        addTopicSelect.innerHTML += `<option value="_new">+ New topic</option>`;

        Object.values(data.topics).forEach((t) => {
  addTopicSelect.innerHTML += `<option value="${t.id}">${t.title}</option>`;
});


        if (lastAddTopic && data.topics[lastAddTopic]) {
          addTopicSelect.value = lastAddTopic;
        } else {
          addTopicSelect.value = "";
        }

        onAddTopicChange();
      }

      function onAddTopicChange() {
        const isNew = addTopicSelect.value === "_new";

        newTopicInput.disabled = !isNew;
        newTopicInput.classList.toggle("hidden", !isNew);

        if (!isNew) {
          newTopicInput.value = "";
        }
      }

  function saveWord() {
  const isNewTopic = addTopicSelect.value === "_new";

  const topicTitle = isNewTopic
    ? newTopicInput.value.trim()
    : data.topics[addTopicSelect.value]?.title;

  if (!topicTitle) return;
  if (!learnInput.value || !translationInput.value) return;

  let topicId;

  // ----- ◊ô◊¶◊ô◊®◊™ Topic ◊ó◊ì◊© -----
  if (isNewTopic) {
    if (isTopicTitleTaken(topicTitle)) {
      alert("Topic with this name already exists.");
      return;
    }

    const topic = createTopic(topicTitle, "local");
    data.topics[topic.id] = topic;
    topicId = topic.id;
  } 
  // ----- Topic ◊ß◊ô◊ô◊ù -----
  else {
    topicId = addTopicSelect.value;
  }

  const topic = data.topics[topicId];
  if (!topic) return;

  // ◊î◊ï◊°◊§◊™ ◊û◊ô◊ú◊î
  topic.words.push({
    id: crypto.randomUUID(),
    learn: learnInput.value,
    tr: translationInput.value,
  });

  save();
  loadTopics();
  updateInstructions();

  // ◊†◊ô◊ß◊ï◊ô ◊©◊ì◊ï◊™
  learnInput.value = "";
  translationInput.value = "";
  newTopicInput.value = "";

  // ----- ◊ó◊ñ◊®◊î ◊ú◊®◊©◊ô◊û◊î ◊ê◊ó◊®◊ô ◊¢◊®◊ô◊õ◊î -----
  if (returnToTopicAfterSave) {
    setCurrentTopic(returnToTopicAfterSave);
    returnToTopicAfterSave = null;
    show("bankList");
    renderWordList();
    return;
  }

  // ----- ◊û◊¶◊ë ◊®◊í◊ô◊ú: ◊†◊©◊ê◊®◊ô◊ù ◊ë-ADD -----
  setCurrentTopic(topicId);
  loadAddTopics();
  addTopicSelect.value = topicId;
  onAddTopicChange();
}



      /* ===== IMPORT ===== */

      function triggerImport() {
        importFile.click();
      }

      importFile.onchange = (e) => {
  const file = e.target.files[0];
  if (!file) {
    importFile.value = "";
    return;
  }

  const baseTitle = file.name.replace(/\.[^/.]+$/, "").trim();
  if (!baseTitle) {
    alert("Invalid file name");
    importFile.value = "";
    return;
  }

  if (isTopicTitleTaken(baseTitle)) {
    alert("Topic with this name already exists.");
    importFile.value = "";
    return;
  }

  const reader = new FileReader();
  reader.onload = (ev) => {
    const csvText = ev.target.result;

    const topic = createTopic(baseTitle, "local");
    const rows = csvText.split(/\r?\n/);

    rows.forEach((line, i) => {
      if (!line.trim()) return;

      const p = line.split(",");
      if (p.length >= 2) {
        topic.words.push({
          id: crypto.randomUUID(),
          learn: p[0].replace(/"/g, "").trim(),
          tr: p.slice(1).join(",").replace(/"/g, "").trim(),
        });
      }
    });

    if (topic.words.length === 0) {
      alert("File contains no valid words");
      importFile.value = "";
      return;
    }

    data.topics[topic.id] = topic;

    save();
    loadTopics();
    updateInstructions();

    setCurrentTopic(topic.id);
    importFile.value = "";

    startSessionSafe(topic.id);
  };

  reader.readAsText(file, "UTF-8");
};

      /* ===== SESSION ===== */

      // session state (single source of truth)
      let session = [];
      let current = null;
      let cardFlipped = false;
      let shuffleUsed = false;
      let sessionDefaultDirection = "A";

      function exitSessionSafe(nextScreen) {
        if (stats.current) {
          finishSessionIfActive();
        }

        if (nextScreen) {
          show(nextScreen);
        } else {
          show("home");
        }
      }

      function startSessionSafe(topicName) {
        // ◊°◊í◊ô◊®◊™ ◊°◊©◊ü ◊ß◊ï◊ì◊ù ◊ê◊ù ◊ß◊ô◊ô◊ù
        if (stats.current) {
          finishSessionIfActive();
        }

        // ◊ë◊ó◊ô◊®◊™ ◊†◊ï◊©◊ê ◊ë◊¶◊ï◊®◊î ◊û◊ë◊ï◊ß◊®◊™
        setCurrentTopic(topicName);

        startSession();
      }

      function startSession() {
  if (!currentTopic) return;

  // reset session state
  session = [];
  current = null;
  cardFlipped = false;
  shuffleUsed = false;
  sessionDefaultDirection = "A";

  // ----- HARD WORDS -----
  if (currentTopic === "Hard Words") {
    session = Object.entries(stats.hardWords)
      .filter((e) => e[1] >= 2)
      .map((e) => {
        const [learn, tr] = e[0].split("||");
        return { learn, tr };
      });

    if (session.length === 0) {
      alert("No hard words to practice yet.");
      show("home");
      return;
    }
  }
  // ----- NORMAL TOPIC -----
  else {
    const topic = data.topics[currentTopic];
    if (!topic) {
      alert("Topic not found.");
      return;
    }

    session = [...topic.words];

    const sort = sortSelect.value;
    if (sort === "learn") {
      session.sort((a, b) => a.learn.localeCompare(b.learn));
    }
    if (sort === "tr") {
      session.sort((a, b) => a.tr.localeCompare(b.tr));
    }

    if (session.length === 0) {
      alert("This topic has no words.");
      show("bank");
      return;
    }
  }

  // ----- START SESSION -----
  shuffleBtn.classList.remove("hidden");

  stats.sessions++;
  stats.current = {
    topic: currentTopic,
    correct: 0,
    wrong: 0,
  };

  nextCard();
}


function nextCard() {
  if (session.length === 0) {
    stats.history.push(stats.current);
    stats.history = stats.history.slice(-10);

    const t = stats.current.topic;
    if (!stats.perTopic[t]) stats.perTopic[t] = { correct: 0, wrong: 0 };
    stats.perTopic[t].correct += stats.current.correct;
    stats.perTopic[t].wrong += stats.current.wrong;

    save();
    show("sessionEnd");
    return;
  }

  current = session[0];
  cardFlipped = false;
  renderCard();
  show("session");
}


      function renderCard() {
        let side = cardFlipped
          ? sessionDefaultDirection === "A"
            ? "B"
            : "A"
          : sessionDefaultDirection;

        const text = side === "A" ? current.learn : current.tr;
        card.textContent = text;

        requestAnimationFrame(() => {
          autoFitCardText();
        });

        document.getElementById("remainingCount").textContent = session.length;
      }

      function autoFitCardText() {
  const maxFont = 72;   // ◊™◊ß◊®◊î ◊°◊ë◊ô◊®◊î
  const minFont = 16;

  let size = maxFont;
  card.style.fontSize = size + "px";

  while (size > minFont) {
    card.style.fontSize = size + "px";

    if (
      card.scrollHeight > card.clientHeight ||
      card.scrollWidth > card.clientWidth
    ) {
      size -= 2;
    } else {
      break;
    }
  }
}

      function flipCard() {
        cardFlipped = !cardFlipped;
        if (soundOn) {
          flipSound.currentTime = 0;
          flipSound.play();
        }
        renderCard();
      }

      function flipDirection() {
        sessionDefaultDirection = sessionDefaultDirection === "A" ? "B" : "A";
        cardFlipped = false;
        renderCard();
      }

      function shuffleSession() {
        if (shuffleUsed) return;

        shuffleUsed = true;
        shuffleBtn.classList.add("hidden");

        session.sort(() => Math.random() - 0.5);

        current = session[0];
        cardFlipped = false;
        renderCard();
      }

      function markKnown() {
        if (soundOn) {
          correctSound.currentTime = 0;
          correctSound.play();
        }
        stats.current.correct++;
        session.shift();
        nextCard();
      }

      function markUnknown() {
        stats.current.wrong++;
        let key = current.learn + "||" + current.tr;
        stats.hardWords[key] = (stats.hardWords[key] || 0) + 1;
        session.push(session.shift());
        nextCard();
      }

      function finishSessionIfActive() {
        if (!stats.current) return;

        stats.history.push(stats.current);

        stats.history = stats.history.slice(-10);

        const t = stats.current.topic;
        if (!stats.perTopic[t]) {
          stats.perTopic[t] = { correct: 0, wrong: 0 };
        }

        stats.perTopic[t].correct += stats.current.correct;
        stats.perTopic[t].wrong += stats.current.wrong;

        stats.current = null;
        save();
      }

      function loadCSVToSession(csvText, topicTitle) {
        session = [];

        csvText.split(/\r?\n/).forEach((line, i) => {
          if (i === 0) return;
          const p = line.split(",");
          if (p.length >= 2) {
            session.push({
              learn: p[0].replace(/"/g, ""),
              tr: p.slice(1).join(",").replace(/"/g, ""),
            });
          }
        });

        if (session.length === 0) return;

        setCurrentTopic(topicTitle);
        sessionDefaultDirection = "A";
        cardFlipped = false;
        shuffleUsed = false;

        stats.sessions++;
        stats.current = { topic: currentTopic, correct: 0, wrong: 0 };

        nextCard();
      }

      /* ===== STATS ===== */
     


 function renderStats() {

        let topics = Object.values(data.topics).length;
        let words = allWords().length;

        let topicStats = "";
        Object.keys(stats.perTopic).forEach((t) => {
          let c = stats.perTopic[t].correct;
          let w = stats.perTopic[t].wrong;
          let acc = c + w > 0 ? Math.round((c / (c + w)) * 100) : 0;
          topicStats += `
      <div class="stat-block">
        <strong>Topic: ${data.topics[t]?.title || t}</strong><br>
        Correct: ${c}<br>
        Wrong: ${w}<br>
        Accuracy: ${acc}%
      </div>`;
        });

        const hardEntries = Object.entries(stats.hardWords)
          .filter((e) => e[1] >= 2)
          .sort((a, b) => b[1] - a[1]);

        const hardTable = hardEntries.length
          ? `
      <h3>Hard Words</h3>
      <table class="hard-table">
        <thead>
          <tr>
            <th>Word</th>
            <th>Times Wrong</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          ${hardEntries
            .map(([key, count]) => {
              const [learn, tr] = key.split("||");
              const safeKey = key.replace(/'/g, "\\'");
              return `
                <tr>
                  <td class="hard-word">${learn} ‚Äì ${tr}</td>
                  <td class="hard-count">${count}</td>
                  <td style="text-align:right">
                    <button
                      class="button-danger"
                      style="padding:6px 10px;font-size:14px"
                      onclick="removeHardWord('${safeKey}')">
                      Remove
                    </button>
                  </td>
                </tr>`;
            })
            .join("")}
        </tbody>
      </table>`
          : `<h3>Hard Words</h3><p>No hard words</p>`;

        statsContent.innerHTML = `
    <p>Topics: ${topics}</p>
    <p>Words: ${words}</p>
    <p>Sessions started: ${stats.sessions}</p>
    <hr>
    <h3>By topic</h3>
    ${topicStats || "<p>No data</p>"}
    <hr>
    ${hardTable}
  `;
      }

      function removeHardWord(key) {
        if (!stats.hardWords[key]) return;

        delete stats.hardWords[key];
        save();
        renderStats();
      }

      function resetStats() {
        if (!confirm("Reset ALL statistics?")) return;

        stats = {
          sessions: 0,
          history: [],
          perTopic: {},
          hardWords: {},
        };

        localStorage.setItem(STATS_KEY, JSON.stringify(stats));

        renderStats();
      }

      /* ===== MISC ===== */

      /* == reset == */
      async function hardReset() {
        localStorage.clear();

        if ("caches" in window) {
          const keys = await caches.keys();
          await Promise.all(keys.map((k) => caches.delete(k)));
        }

        if ("serviceWorker" in navigator) {
          const regs = await navigator.serviceWorker.getRegistrations();
          await Promise.all(regs.map((r) => r.unregister()));
        }

        localStorage.setItem(RESET_FLAG, "1");
        location.reload();
      }

      function toggleAccordion(header) {
        const acc = header.parentElement;
        const container = acc.parentElement; // #downloadAccordions ◊ê◊ï #bank (◊ê◊ù ◊ë◊¢◊™◊ô◊ì)

        // ◊°◊í◊ô◊®◊™ ◊õ◊ú ◊î◊ê◊ß◊ï◊®◊ì◊ô◊ï◊†◊ô◊ù ◊ë◊ê◊ï◊™◊ï ◊û◊°◊ö
        container.querySelectorAll(".accordion.open").forEach((a) => {
          if (a !== acc) a.classList.remove("open");
        });

        // toggle ◊®◊ß ◊©◊ú ◊î◊†◊ï◊õ◊ó◊ô
        acc.classList.toggle("open");
      }

      const restartBtn = document.getElementById("restartSessionBtn");
      if (restartBtn) {
        restartBtn.onclick = () => {
          shuffleUsed = false;
          startSession();
        };
      }

      const backBtn = document.getElementById("backHomeBtn");
      if (backBtn) {
        backBtn.onclick = () => {
          goHome();
        };
      }

      /* ===== HUB ‚Üí DOWNLOAD ADAPTER ===== */

      function getDownloadTree(lang) {
        if (!hubIndex || !lang) return [];

        const tree = {};

        hubIndex.entries.forEach((entry) => {
          const { branch, group, files } = entry;
          const langFiles = files?.[lang];
          if (!langFiles || !langFiles.length) return;

          if (!tree[branch]) {
            tree[branch] = {};
          }
          if (!tree[branch][group]) {
            tree[branch][group] = [];
          }

          langFiles.forEach((f) => {
            tree[branch][group].push(f);
          });
        });

        return tree;
      }

      /* ===== DOWNLOAD ===== */

      async function buildDownloadUI() {
        if (!hubIndex || !currentDownloadLang) return;

        const tree = getDownloadTree(currentDownloadLang);
        const container = document.getElementById("downloadAccordions");
        container.innerHTML = "";

        Object.keys(tree).forEach((branchId) => {
          const acc = document.createElement("div");
          acc.className = "accordion";

          acc.innerHTML = `
      <div class="accordion-header" onclick="toggleAccordion(this)">
        ${branchId} <span>‚ñ∂</span>
      </div>
      <div class="accordion-content"></div>
    `;

          const content = acc.querySelector(".accordion-content");

          Object.keys(tree[branchId]).forEach((groupId) => {
            const groupDiv = document.createElement("div");
            groupDiv.className = "download-group";
            groupDiv.innerHTML = `<strong>${groupId}</strong>`;

            const ul = document.createElement("ul");

            tree[branchId][groupId].forEach((fileName) => {
              const li = document.createElement("li");
              li.className = "li-available";
              li.textContent = fileName.replace(/\.csv$/i, "");

              li.onclick = () => {
                const path = `hub/${currentDownloadLang}/${branchId}/${groupId}/${fileName}`;
                onDownloadFile(path, `${groupId}`, fileName);
              };

              ul.appendChild(li);
            });

            groupDiv.appendChild(ul);
            content.appendChild(groupDiv);
          });

          container.appendChild(acc);
        });
      }

      async function onDownloadFile(path, groupId, fileName) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 15000);

  try {
    const res = await fetch(path, { signal: controller.signal });
    if (!res.ok) {
      alert("File not found");
      return;
    }

    const csvText = await res.text();

    const baseName = fileName.replace(/\.csv$/i, "");
    const topicTitle = `${groupId} ¬∑ ${baseName}`;

    const topicId = saveCSVAsTopic(csvText, topicTitle, "hub", {
      path,
      groupId,
      fileName,
      lang: currentDownloadLang,
    });

    if (!topicId) return;

    setCurrentTopic(topicId);
    startSessionSafe(topicId);
  } catch (e) {
    alert("Download failed or timed out.");
  } finally {
    clearTimeout(timeoutId);
  }
}

      /* ===== DOWNLOAD LANGUAGE SELECTION ===== */

      let currentDownloadLang = null;
      const downloadLangSelect = document.getElementById("downloadLangSelect");

      if (downloadLangSelect) {
        downloadLangSelect.addEventListener("change", () => {
          currentDownloadLang = downloadLangSelect.value || null;
          markActiveDownloadLang();
          buildDownloadUI();
          closeAllAccordions();
        });
      }

      function markActiveDownloadLang() {
        downloadLangSelect.classList.remove(
          "lang-he-en",
          "lang-pl-en",
          "lang-ar-he",
          "lang-es-he",
        );

        const acc = document.getElementById("downloadAccordions");

        if (currentDownloadLang) {
          downloadLangSelect.classList.add("lang-" + currentDownloadLang);
          if (acc) acc.classList.remove("lang-not-selected");
        } else {
          if (acc) acc.classList.add("lang-not-selected");
        }
      }

      function closeAllAccordions() {
        document
          .querySelectorAll("#download .accordion.open")
          .forEach((acc) => acc.classList.remove("open"));
      }

      function exitApp() {
        // PWA / Mobile
        if (navigator.userAgent.includes("Android")) {
          navigator.app?.exitApp?.();
        }

        // ◊ì◊§◊ì◊§◊ü ◊®◊í◊ô◊ú ‚Äì ◊ó◊ñ◊®◊î ◊ê◊ó◊ï◊®◊î
        window.history.back();
      }

      function gateUntilReset() {
        if (localStorage.getItem(RESET_FLAG)) return;

        document
          .querySelectorAll(".screen")
          .forEach((s) => s.classList.remove("active"));

        document.getElementById("resetGate").classList.add("active");
      }

      /* ===== GLOBAL EXPORTS (for inline onclick) ===== */

      window.startSessionSafe = startSessionSafe;
      window.showStats = showStats;
      window.showBank = showBank;
      window.showDownload = showDownload;
      window.goHome = goHome;

      window.flipCard = flipCard;
      window.markKnown = markKnown;
      window.markUnknown = markUnknown;
      window.shuffleSession = shuffleSession;

      window.toggleAccordion = toggleAccordion;
      window.removeHardWord = removeHardWord;
      window.exitApp = exitApp;

      /* ===== INIT (SAFE) ===== */

const APP_VERSION = 555;
const APP_VERSION_KEY = "app_version";

(function bootstrapVersionGate() {
  const stored = Number(localStorage.getItem(APP_VERSION_KEY));

  if (stored !== APP_VERSION) {
    localStorage.clear();
    localStorage.setItem(APP_VERSION_KEY, APP_VERSION);
    localStorage.setItem(RESET_FLAG, "1");
  }
})();

(function startApp() {
  gateUntilReset(); // ◊ê◊ù ◊î◊ó◊ú◊ò◊™ ◊ú◊î◊©◊ê◊ô◊® ◊ê◊ï◊™◊ï
  loadHubIndex();
  loadTopics();
  updateInstructions();
})();

    </script>
  </body>
</html>